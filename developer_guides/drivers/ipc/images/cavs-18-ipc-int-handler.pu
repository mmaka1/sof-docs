participant int_disp as "Interrupt\nDispatcher"
participant ipc_drv as "IPC Driver"
participant ipc_task as "IPC Task"

int_disp -> ipc_drv : HandleInt()
   activate ipc_drv
   ipc_drv -> ipc_drv: IsDownStreamInUse() : <b>DIPCT.BUSY</b> == 1
   ipc_drv -> ipc_drv: HandleDoneBitInterrupt() : done_set
      activate ipc_drv
      opt DIPCIDA.DONE == 1
         ipc_drv -> ipc_drv : <b>DIPCIDA.DONE</b> := 1
         ipc_drv -> ipc_drv : done_set := 1
      end opt
      deactivate ipc_drv

   opt done_set and not UpstreamInUse()
      ipc_drv -> ipc_drv : SendMessage()
   end opt

   opt DIPCT.BUSY
      ipc_drv -> ipc_drv : <b>DIPCCTL.IPCTBIE</b> := 0
      note right
         If Busy bit is set - disable busy bit interrupts in
         the IPC comm control register. It will stay that way
         until the message is confirmed by the IpcTask.
      end note
      ipc_drv -> ipc_task : SetPendingRequest(true)
      note right
         It marks ipc task state as ready to run once interrupt
         handler exits and scheduler is invoked.
      end note
   end opt

int_disp <-- ipc_drv
deactivate ipc_drv
